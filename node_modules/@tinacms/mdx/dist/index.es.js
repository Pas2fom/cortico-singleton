var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/parse/index.ts
import { remark } from "remark";
import remarkMdx from "remark-mdx";

// src/parse/remarkToPlate.ts
import { flatten } from "lodash-es";

// src/parse/acorn.ts
var extractAttributes = (attributes, fields, imageCallback) => {
  const properties = {};
  attributes.forEach((attribute) => {
    assertType(attribute, "mdxJsxAttribute");
    const field = fields.find((field2) => field2.name === attribute.name);
    if (!field) {
      throw new Error(`Unable to find field definition for property "${attribute.name}"`);
    }
    try {
      properties[attribute.name] = extractAttribute(attribute, field, imageCallback);
    } catch (e) {
      if (e instanceof Error) {
        throw new Error(`Unable to parse field value for field "${field.name}" (type: ${field.type}). ${e.message}`);
      }
      throw e;
    }
  });
  return properties;
};
var extractAttribute = (attribute, field, imageCallback) => {
  switch (field.type) {
    case "boolean":
    case "number":
      return extractScalar(extractExpression(attribute), field);
    case "datetime":
    case "string":
      if (field.list) {
        return extractScalar(extractExpression(attribute), field);
      } else {
        return extractString(attribute, field);
      }
    case "image":
      if (field.list) {
        const values = extractScalar(extractExpression(attribute), field);
        return values.split(",").map((value) => imageCallback(value));
      } else {
        const value = extractString(attribute, field);
        return imageCallback(value);
      }
    case "reference":
      if (field.list) {
        return extractScalar(extractExpression(attribute), field);
      } else {
        return extractString(attribute, field);
      }
    case "object":
      return extractObject(extractExpression(attribute), field);
    case "rich-text":
      const JSXString = extractRaw(attribute);
      if (JSXString) {
        return parseMDX(JSXString, field, imageCallback);
      } else {
        return {};
      }
    default:
      throw new Error(`Extract attribute: Unhandled field type ${field.type}`);
  }
};
var extractScalar = (attribute, field) => {
  if (field.list) {
    assertType(attribute.expression, "ArrayExpression");
    return attribute.expression.elements.map((element) => {
      assertHasType(element);
      assertType(element, "Literal");
      return element.value;
    });
  } else {
    assertType(attribute.expression, "Literal");
    return attribute.expression.value;
  }
};
var extractObject = (attribute, field) => {
  if (field.list) {
    assertType(attribute.expression, "ArrayExpression");
    return attribute.expression.elements.map((element) => {
      assertHasType(element);
      assertType(element, "ObjectExpression");
      return extractObjectExpression(element, field);
    });
  } else {
    assertType(attribute.expression, "ObjectExpression");
    return extractObjectExpression(attribute.expression, field);
  }
};
var extractObjectExpression = (expression, field) => {
  const properties = {};
  expression.properties.forEach((property) => {
    assertType(property, "Property");
    const { key, value } = extractKeyValue(property, field);
    properties[key] = value;
  });
  return properties;
};
var getField = (objectField, name) => {
  if (objectField.fields) {
    if (typeof objectField.fields === "string") {
      throw new Error("Global templates not supported");
    }
    return objectField.fields.find((f) => f.name === name);
  }
};
var extractKeyValue = (property, parentField) => {
  assertType(property.key, "Identifier");
  const key = property.key.name;
  const field = getField(parentField, key);
  if (field?.type === "object") {
    if (field.list) {
      assertType(property.value, "ArrayExpression");
      const value = property.value.elements.map((element) => {
        assertHasType(element);
        assertType(element, "ObjectExpression");
        return extractObjectExpression(element, field);
      });
      return { key, value };
    } else {
      assertType(property.value, "ObjectExpression");
      const value = extractObjectExpression(property.value, field);
      return { key, value };
    }
  } else {
    assertType(property.value, "Literal");
    return { key, value: property.value.value };
  }
};
var extractStatement = (attribute) => {
  const body = attribute.data?.estree?.body;
  if (body) {
    if (body[0]) {
      assertType(body[0], "ExpressionStatement");
      return body[0];
    }
  }
  throw new Error(`Unable to extract body from expression`);
};
var extractString = (attribute, field) => {
  if (attribute.type === "mdxJsxAttribute") {
    if (typeof attribute.value === "string") {
      return attribute.value;
    }
  }
  return extractScalar(extractExpression(attribute), field);
};
var extractExpression = (attribute) => {
  assertType(attribute, "mdxJsxAttribute");
  assertHasType(attribute.value);
  assertType(attribute.value, "mdxJsxAttributeValueExpression");
  return extractStatement(attribute.value);
};
var extractRaw = (attribute) => {
  assertType(attribute, "mdxJsxAttribute");
  assertHasType(attribute.value);
  assertType(attribute.value, "mdxJsxAttributeValueExpression");
  const rawValue = attribute.value.value;
  return trimFragments(rawValue);
};
function assertType(val, type) {
  if (val.type !== type) {
    throw new Error(`Expected type to be ${type} but received ${val.type}. ${MDX_PARSE_ERROR_MSG}`);
  }
}
function assertHasType(val) {
  if (val) {
    if (typeof val !== "string") {
      return;
    }
  }
  throw new Error(`Expect value to be an object with property "type"`);
}
var trimFragments = (string) => {
  const rawArr = string.split("\n");
  let openingFragmentIndex = null;
  let closingFragmentIndex = null;
  rawArr.forEach((item, index) => {
    if (item.trim() === "<>") {
      if (!openingFragmentIndex) {
        openingFragmentIndex = index + 1;
      }
    }
  });
  rawArr.reverse().forEach((item, index) => {
    if (item.trim() === "</>") {
      const length = rawArr.length - 1;
      if (!closingFragmentIndex) {
        closingFragmentIndex = length - index;
      }
    }
  });
  const value = rawArr.reverse().slice(openingFragmentIndex || 0, closingFragmentIndex || rawArr.length - 1).join("\n");
  return value;
};

// src/parse/mdx.ts
import { toMarkdown } from "mdast-util-to-markdown";
import { mdxJsxToMarkdown } from "mdast-util-mdx-jsx";
function mdxJsxElement(node, field, imageCallback) {
  try {
    const template = field.templates?.find((template2) => {
      const templateName = typeof template2 === "string" ? template2 : template2.name;
      return templateName === node.name;
    });
    if (typeof template === "string") {
      throw new Error("Global templates not yet supported");
    }
    if (!template) {
      const string = toMarkdown({ type: "root", children: [node] }, {
        extensions: [mdxJsxToMarkdown()],
        listItemIndent: "one"
      });
      return {
        type: node.type === "mdxJsxFlowElement" ? "html" : "html_inline",
        value: string.trim(),
        children: [{ type: "text", text: "" }]
      };
    }
    const props = extractAttributes(node.attributes, template.fields, imageCallback);
    const childField = template.fields.find((field2) => field2.name === "children");
    if (childField) {
      if (childField.type === "rich-text") {
        props.children = remarkToSlate(node, childField, imageCallback);
      }
    }
    return {
      type: node.type,
      name: node.name,
      children: [{ type: "text", text: "" }],
      props
    };
  } catch (e) {
    if (e instanceof Error) {
      throw new RichTextParseError(e.message, node.position);
    }
    throw e;
  }
}

// src/parse/remarkToPlate.ts
var remarkToSlate = (root, field, imageCallback) => {
  const content = (content2) => {
    switch (content2.type) {
      case "blockquote":
        const children = [];
        content2.children.map((child) => {
          const inlineElements = unwrapBlockContent(child);
          inlineElements.forEach((child2) => {
            children.push(child2);
          });
        });
        return {
          type: "blockquote",
          children
        };
      case "heading":
        return heading(content2);
      case "code":
        return code(content2);
      case "paragraph":
        return paragraph(content2);
      case "mdxJsxFlowElement":
        return mdxJsxElement(content2, field, imageCallback);
      case "thematicBreak":
        return {
          type: "hr",
          children: [{ type: "text", text: "" }]
        };
      case "listItem":
        return {
          type: "li",
          children: [
            {
              type: "lic",
              children: flatten(content2.children.map((child) => unwrapBlockContent(child)))
            }
          ]
        };
      case "list":
        return list(content2);
      case "html":
        return html(content2);
      case "mdxFlowExpression":
      case "mdxjsEsm":
        throw new RichTextParseError(`Unexpected expression ${content2.value}.`, content2.position);
      default:
        throw new RichTextParseError(`Content: ${content2.type} is not yet supported`, content2.position);
    }
  };
  const html = (content2) => {
    return {
      type: "html",
      value: content2.value,
      children: [{ type: "text", text: "" }]
    };
  };
  const html_inline = (content2) => {
    return {
      type: "html_inline",
      value: content2.value,
      children: [{ type: "text", text: "" }]
    };
  };
  const list = (content2) => {
    return {
      type: content2.ordered ? "ol" : "ul",
      children: content2.children.map((child) => listItem(child))
    };
  };
  const listItem = (content2) => {
    return {
      type: "li",
      children: content2.children.map((child) => {
        switch (child.type) {
          case "list":
            return list(child);
          case "heading":
          case "paragraph":
            return {
              type: "lic",
              children: flatten(child.children.map((child2) => phrasingContent(child2)))
            };
          case "blockquote": {
            return {
              ...blockquote(child),
              type: "lic"
            };
          }
          case "mdxJsxFlowElement":
            return {
              type: "lic",
              children: [
                mdxJsxElement({ ...child, type: "mdxJsxTextElement" }, field, imageCallback)
              ]
            };
          case "code":
          case "thematicBreak":
          case "table":
          case "html":
            throw new RichTextParseError(`${child.type} inside list item is not supported`, child.position);
          default:
            throw new RichTextParseError(`Unknown list item of type ${child.type}`, child.position);
        }
      })
    };
  };
  const unwrapBlockContent = (content2) => {
    const flattenPhrasingContent = (children) => {
      const children2 = children.map((child) => phrasingContent(child));
      return flatten(Array.isArray(children2) ? children2 : [children2]);
    };
    switch (content2.type) {
      case "heading":
      case "paragraph":
        return flattenPhrasingContent(content2.children);
      default:
        throw new Error(`UnwrapBlock: Unknown block content of type ${content2.type}`);
    }
  };
  const code = (content2) => {
    const extra = {};
    if (content2.lang)
      extra["lang"] = content2.lang;
    return {
      type: "code_block",
      ...extra,
      value: content2.value,
      children: [{ type: "text", text: "" }]
    };
  };
  const link = (content2) => {
    return {
      type: "a",
      url: content2.url,
      title: content2.title,
      children: flatten(content2.children.map((child) => staticPhrasingContent(child)))
    };
  };
  const heading = (content2) => {
    return {
      type: ["h1", "h2", "h3", "h4", "h5", "h6"][content2.depth - 1],
      children: flatten(content2.children.map(phrasingContent))
    };
  };
  const staticPhrasingContent = (content2) => {
    switch (content2.type) {
      case "mdxJsxTextElement":
        return mdxJsxElement(content2, field, imageCallback);
      case "text":
        return text2(content2);
      case "inlineCode":
      case "emphasis":
      case "image":
      case "strong":
        return phrashingMark(content2);
      default:
        throw new Error(`StaticPhrasingContent: ${content2.type} is not yet supported`);
    }
  };
  const phrasingContent = (content2) => {
    switch (content2.type) {
      case "text":
        return text2(content2);
      case "link":
        return link(content2);
      case "image":
        return image(content2);
      case "mdxJsxTextElement":
        return mdxJsxElement(content2, field, imageCallback);
      case "emphasis":
        return phrashingMark(content2);
      case "strong":
        return phrashingMark(content2);
      case "break":
        return breakContent();
      case "inlineCode":
        return phrashingMark(content2);
      case "html":
        return html_inline(content2);
      case "mdxTextExpression":
        throw new RichTextParseError(`Unexpected expression ${content2.value}.`, content2.position);
      default:
        throw new Error(`PhrasingContent: ${content2.type} is not yet supported`);
    }
  };
  const breakContent = () => {
    return {
      type: "break",
      children: [
        {
          type: "text",
          text: ""
        }
      ]
    };
  };
  const phrashingMark = (node, marks = []) => {
    const accum = [];
    switch (node.type) {
      case "emphasis": {
        const children = flatten(node.children.map((child) => phrashingMark(child, [...marks, "italic"])));
        children.forEach((child) => {
          accum.push(child);
        });
        break;
      }
      case "inlineCode": {
        const markProps2 = {};
        marks.forEach((mark) => markProps2[mark] = true);
        accum.push({
          type: "text",
          text: node.value,
          code: true,
          ...markProps2
        });
        break;
      }
      case "strong": {
        const children = flatten(node.children.map((child) => phrashingMark(child, [...marks, "bold"])));
        children.forEach((child) => {
          accum.push(child);
        });
        break;
      }
      case "image": {
        accum.push(image(node));
        break;
      }
      case "link": {
        const children = flatten(node.children.map((child) => phrashingMark(child, marks)));
        accum.push({ type: "a", url: node.url, title: node.title, children });
        break;
      }
      case "text":
        const markProps = {};
        marks.forEach((mark) => markProps[mark] = true);
        accum.push({ type: "text", text: node.value, ...markProps });
        break;
      default:
        throw new Error(`Unexpected inline element of type ${node.type}`);
    }
    return accum;
  };
  const image = (content2) => {
    return {
      type: "img",
      url: imageCallback(content2.url),
      alt: content2.alt,
      caption: content2.title,
      children: [{ type: "text", text: "" }]
    };
  };
  const text2 = (content2) => {
    return {
      type: "text",
      text: content2.value
    };
  };
  const blockquote = (content2) => {
    const children = [];
    content2.children.map((child) => {
      const inlineElements = unwrapBlockContent(child);
      inlineElements.forEach((child2) => {
        children.push(child2);
      });
    });
    return {
      type: "blockquote",
      children
    };
  };
  const paragraph = (content2) => {
    const children = flatten(content2.children.map(phrasingContent));
    if (children.length === 1) {
      if (children[0]) {
        if (children[0].type === "html_inline") {
          return {
            ...children[0],
            type: "html"
          };
        }
      }
    }
    return {
      type: "p",
      children
    };
  };
  return {
    type: "root",
    children: root.children.map((child) => {
      return content(child);
    })
  };
};
var RichTextParseError = class extends Error {
  constructor(message, position) {
    super(message);
    __publicField(this, "position");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, RichTextParseError);
    }
    this.name = "RichTextParseError";
    this.position = position;
  }
};

// src/parse/parseShortcode.ts
function parseShortcode(preprocessedString, template) {
  const match = template.match;
  const unkeyedAttributes = !!template.fields.find((t) => t.name === "_value");
  const hasChildren = !!template.fields.find((t) => t.name == "children");
  const replacement = `<${template.name} ${unkeyedAttributes ? '_value="$1"' : "$1"}>${hasChildren ? "$2" : "\n"}</${template.name}>`;
  const endRegex = `((?:.|\\n)*)${match.start}\\s/\\s*${match.name || template.name}[\\s]*${match.end}`;
  const regex = `${match.start}\\s*${match.name || template.name}[\\s]+${unkeyedAttributes ? `['"]?(.*?)['"]?` : "(.*?)"}[\\s]*${match.end}${hasChildren ? endRegex : ""}`;
  return replaceAll(preprocessedString, regex, replacement);
}

// src/parse/index.ts
var markdownToAst = (value, field) => {
  const templatesWithMatchers = field.templates?.filter((template) => template.match);
  let preprocessedString = value;
  templatesWithMatchers?.forEach((template) => {
    if (typeof template === "string") {
      throw new Error("Global templates are not supported");
    }
    if (template.match) {
      if (preprocessedString) {
        preprocessedString = parseShortcode(preprocessedString, template);
      }
    }
  });
  try {
    const tree = remark().use(remarkMdx).parse(preprocessedString);
    if (!tree) {
      throw new Error("Error parsing markdown");
    }
    return tree;
  } catch (e) {
    console.error("error parsing file: ", e);
    throw new RichTextParseError(e, e.position);
  }
};
var MDX_PARSE_ERROR_MSG = "TinaCMS supports a stricter version of markdown and a subset of MDX. https://tina.io/docs/editing/mdx/#differences-from-other-mdx-implementations";
var parseMDX = (value, field, imageCallback) => {
  let tree;
  try {
    tree = markdownToAst(value, field);
    if (tree) {
      return remarkToSlate(tree, field, imageCallback);
    } else {
      return { type: "root", children: [] };
    }
  } catch (e) {
    if (e instanceof RichTextParseError) {
      return invalidMarkdown(e, value);
    }
    return invalidMarkdown(new RichTextParseError(e.message), value);
  }
};
var invalidMarkdown = (e, value) => {
  const extra = {};
  if (e.position && Object.keys(e.position).length) {
    extra["position"] = e.position;
  }
  return {
    type: "root",
    children: [
      {
        type: "invalid_markdown",
        value,
        message: e.message || `Error parsing markdown ${MDX_PARSE_ERROR_MSG}`,
        children: [{ type: "text", text: "" }],
        ...extra
      }
    ]
  };
};
var replaceAll = (string, target, value) => {
  const regex = new RegExp(target, "g");
  return string.valueOf().replace(regex, value);
};

// src/stringify/index.ts
import { toMarkdown as toMarkdown2 } from "mdast-util-to-markdown";
import {
  mdxJsxToMarkdown as mdxJsxToMarkdown2
} from "mdast-util-mdx-jsx";

// src/stringify/acorn.ts
import { format } from "prettier";
var stringifyPropsInline = (element, field, imageCallback) => {
  return stringifyProps(element, field, true, imageCallback);
};
function stringifyProps(element, parentField, flatten2, imageCallback) {
  const attributes = [];
  const children = [];
  const template = parentField.templates?.find((template2) => {
    if (typeof template2 === "string") {
      throw new Error("Global templates not supported");
    }
    return template2.name === element.name;
  });
  if (!template || typeof template === "string") {
    throw new Error(`Unable to find template for JSX element ${element.name}`);
  }
  Object.entries(element.props).forEach(([name, value]) => {
    const field = template.fields.find((field2) => field2.name === name);
    if (!field) {
      if (name === "children") {
        return;
      }
      throw new Error(`No field definition found for property ${name}`);
    }
    switch (field.type) {
      case "reference":
        if (field.list) {
          if (Array.isArray(value)) {
            attributes.push({
              type: "mdxJsxAttribute",
              name,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `[${value.map((item) => `"${item}"`).join(", ")}]`
              }
            });
          }
        } else {
          if (typeof value === "string") {
            attributes.push({
              type: "mdxJsxAttribute",
              name,
              value
            });
          }
        }
        break;
      case "datetime":
      case "string":
        if (field.list) {
          if (Array.isArray(value)) {
            attributes.push({
              type: "mdxJsxAttribute",
              name,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `[${value.map((item) => `"${item}"`).join(", ")}]`
              }
            });
          }
        } else {
          if (typeof value === "string") {
            attributes.push({
              type: "mdxJsxAttribute",
              name,
              value
            });
          } else {
            throw new Error(`Expected string for attribute on field ${field.name}`);
          }
        }
        break;
      case "image":
        if (field.list) {
          if (Array.isArray(value)) {
            attributes.push({
              type: "mdxJsxAttribute",
              name,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `[${value.map((item) => `"${imageCallback(item)}"`).join(", ")}]`
              }
            });
          }
        } else {
          attributes.push({
            type: "mdxJsxAttribute",
            name,
            value: imageCallback(String(value))
          });
        }
        break;
      case "number":
      case "boolean":
        if (field.list) {
          if (Array.isArray(value)) {
            attributes.push({
              type: "mdxJsxAttribute",
              name,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `[${value.map((item) => `${item}`).join(", ")}]`
              }
            });
          }
        } else {
          attributes.push({
            type: "mdxJsxAttribute",
            name,
            value: {
              type: "mdxJsxAttributeValueExpression",
              value: String(value)
            }
          });
        }
        break;
      case "object":
        attributes.push({
          type: "mdxJsxAttribute",
          name,
          value: {
            type: "mdxJsxAttributeValueExpression",
            value: stringifyObj(value, flatten2)
          }
        });
        break;
      case "rich-text":
        if (typeof value === "string") {
          throw new Error(`Unexpected string for rich-text, ensure the value has been properly parsed`);
        }
        if (field.list) {
          throw new Error(`Rich-text list is not supported`);
        } else {
          const joiner = flatten2 ? " " : "\n";
          let val = "";
          assertShape(value, (value2) => value2.type === "root" && Array.isArray(value2.children), `Nested rich-text element is not a valid shape for field ${field.name}`);
          if (field.name === "children") {
            const root = rootElement(value, field, imageCallback);
            root.children.forEach((child) => {
              children.push(child);
            });
            return;
          } else {
            const stringValue = stringifyMDX(value, field, imageCallback);
            if (stringValue) {
              val = stringValue.trim().split("\n").map((str) => `  ${str.trim()}`).join(joiner);
            }
          }
          if (flatten2) {
            attributes.push({
              type: "mdxJsxAttribute",
              name,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `<>${val.trim()}</>`
              }
            });
          } else {
            attributes.push({
              type: "mdxJsxAttribute",
              name,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `<>
${val}
</>`
              }
            });
          }
        }
        break;
      default:
        throw new Error(`Stringify props: ${field.type} not yet supported`);
    }
  });
  if (template.match) {
    return {
      attributes,
      children: children && children.length ? children : [
        {
          type: "paragraph",
          children: [
            {
              type: "text",
              value: ""
            }
          ]
        }
      ]
    };
  }
  return { attributes, children };
}
function stringifyObj(obj, flatten2) {
  if (typeof obj === "object" && obj !== null) {
    const dummyFunc = `const dummyFunc = `;
    const res = format(`${dummyFunc}${JSON.stringify(obj)}`, {
      parser: "acorn",
      trailingComma: "none",
      semi: false
    }).trim().replace(dummyFunc, "");
    return flatten2 ? res.replaceAll("\n", "").replaceAll("  ", " ") : res;
  } else {
    console.log(obj);
    throw new Error(`stringifyObj must be passed an object or an array of objects, received ${typeof obj}`);
  }
}
function assertShape(value, callback, errorMessage) {
  if (!callback(value)) {
    throw new Error(errorMessage || `Failed to assert shape`);
  }
}

// src/stringify/marks.ts
var matches = (a, b) => {
  return a.some((v) => b.includes(v));
};
var replaceLinksWithTextNodes = (content) => {
  const newItems = [];
  content.forEach((item) => {
    if (item.type === "a") {
      if (item.children.length === 1) {
        const firstChild = item.children[0];
        if (firstChild?.type === "text") {
          newItems.push({
            ...firstChild,
            linkifyTextNode: (a) => {
              return {
                type: "link",
                url: item.url,
                title: item.title,
                children: [a]
              };
            }
          });
        } else {
          newItems.push(item);
        }
      } else {
        newItems.push(item);
      }
    } else {
      newItems.push(item);
    }
  });
  return newItems;
};
var inlineElementExceptLink = (content, field, imageCallback) => {
  switch (content.type) {
    case "a":
      throw new Error(`Unexpected node of type "a", link elements should be processed after all inline elements have resolved`);
    case "img":
      return {
        type: "image",
        url: imageCallback(content.url),
        alt: content.alt,
        title: content.caption
      };
    case "break":
      return {
        type: "break"
      };
    case "mdxJsxTextElement": {
      const { attributes, children } = stringifyPropsInline(content, field, imageCallback);
      return {
        type: "mdxJsxTextElement",
        name: content.name,
        attributes,
        children
      };
    }
    case "html_inline": {
      return {
        type: "html",
        value: content.value
      };
    }
    default:
      if (!content.type && typeof content.text === "string") {
        return text(content);
      }
      throw new Error(`InlineElement: ${content.type} is not supported`);
  }
};
var text = (content) => {
  return {
    type: "text",
    value: content.text
  };
};
var eat = (c, field, imageCallback) => {
  const content = replaceLinksWithTextNodes(c);
  const first = content[0];
  if (!first) {
    return [];
  }
  if (first && first?.type !== "text") {
    if (first.type === "a") {
      return [
        {
          type: "link",
          url: first.url,
          title: first.title,
          children: eat(first.children, field, imageCallback)
        },
        ...eat(content.slice(1), field, imageCallback)
      ];
    }
    return [
      inlineElementExceptLink(first, field, imageCallback),
      ...eat(content.slice(1), field, imageCallback)
    ];
  }
  const marks = getMarks(first);
  if (marks.length === 0) {
    if (first.linkifyTextNode) {
      return [
        first.linkifyTextNode(text(first)),
        ...eat(content.slice(1), field, imageCallback)
      ];
    } else {
      return [text(first), ...eat(content.slice(1), field, imageCallback)];
    }
  }
  let nonMatchingSiblingIndex = 0;
  if (content.slice(1).every((content2, index) => {
    if (matches(marks, getMarks(content2))) {
      return true;
    } else {
      nonMatchingSiblingIndex = index;
      return false;
    }
  })) {
    nonMatchingSiblingIndex = content.length - 1;
  }
  const matchingSiblings = content.slice(1, nonMatchingSiblingIndex + 1);
  const markCounts = {};
  marks.forEach((mark) => {
    let count2 = 1;
    matchingSiblings.every((sibling, index) => {
      if (getMarks(sibling).includes(mark)) {
        count2 = index + 1;
        return true;
      }
    });
    markCounts[mark] = count2;
  });
  let count = 0;
  let markToProcess = null;
  Object.entries(markCounts).forEach(([mark, markCount]) => {
    const m = mark;
    if (markCount > count) {
      count = markCount;
      markToProcess = m;
    }
  });
  if (!markToProcess) {
    return [text(first), ...eat(content.slice(1), field, imageCallback)];
  }
  if (markToProcess === "inlineCode") {
    if (nonMatchingSiblingIndex) {
      throw new Error(`Marks inside inline code are not supported`);
    }
    const node = {
      type: markToProcess,
      value: first.text
    };
    return [
      first.linkifyTextNode?.(node) ?? node,
      ...eat(content.slice(nonMatchingSiblingIndex + 1), field, imageCallback)
    ];
  }
  return [
    {
      type: markToProcess,
      children: eat([
        ...[first, ...matchingSiblings].map((sibling) => cleanNode(sibling, markToProcess))
      ], field, imageCallback)
    },
    ...eat(content.slice(nonMatchingSiblingIndex + 1), field, imageCallback)
  ];
};
var cleanNode = (node, mark) => {
  if (!mark) {
    return node;
  }
  const cleanedNode = {};
  const markToClear = {
    strong: "bold",
    emphasis: "italic",
    inlineCode: "code"
  }[mark];
  Object.entries(node).map(([key, value]) => {
    if (key !== markToClear) {
      cleanedNode[key] = value;
    }
  });
  if (node.linkifyTextNode) {
    cleanedNode.callback = node.linkifyTextNode;
  }
  return cleanedNode;
};

// src/stringify/stringifyShortcode.ts
function stringifyShortcode(preprocessedString, template) {
  const match = template.match;
  const unkeyedAttributes = !!template.fields.find((t) => t.name == "_value");
  const regex = `<[\\s]*${template.name}[\\s]*${unkeyedAttributes ? "(?:_value=(.*?))?" : "(.+?)?"}[\\s]*>[\\s]*((?:.|
)*?)[\\s]*</[\\s]*${template.name}[\\s]*>`;
  const closingRegex = `
$2
${match.start} /${match.name || template.name} ${match.end}`;
  const replace = `${match.start} ${match.name || template.name} $1 ${match.end}${template.fields.find((t) => t.name == "children") ? closingRegex : ""}`;
  return replaceAll(preprocessedString, regex, replace);
}

// src/stringify/index.ts
var stringifyMDX = (value, field, imageCallback) => {
  if (!value) {
    return;
  }
  if (typeof value === "string") {
    throw new Error("Expected an object to stringify, but received a string");
  }
  if (value?.children[0]) {
    if (value?.children[0].type === "invalid_markdown") {
      return value.children[0].value;
    }
  }
  const res = toMarkdown2(rootElement(value, field, imageCallback), {
    extensions: [mdxJsxToMarkdown2()],
    listItemIndent: "one"
  });
  const templatesWithMatchers = field.templates?.filter((template) => template.match);
  let preprocessedString = res;
  templatesWithMatchers?.forEach((template) => {
    if (typeof template === "string") {
      throw new Error("Global templates are not supported");
    }
    if (template.match) {
      preprocessedString = stringifyShortcode(preprocessedString, template);
    }
  });
  return preprocessedString;
};
var rootElement = (content, field, imageCallback) => {
  const children = [];
  content.children.forEach((child) => {
    const value = blockElement(child, field, imageCallback);
    if (value) {
      children.push(value);
    }
  });
  return {
    type: "root",
    children
  };
};
var blockElement = (content, field, imageCallback) => {
  switch (content.type) {
    case "h1":
    case "h2":
    case "h3":
    case "h4":
    case "h5":
    case "h6":
      return {
        type: "heading",
        depth: { h1: 1, h2: 2, h3: 3, h4: 4, h5: 5, h6: 6 }[content.type],
        children: eat(content.children, field, imageCallback)
      };
    case "p":
      if (content.children.length === 1) {
        const onlyChild = content.children[0];
        if (onlyChild && onlyChild.type === "text" && onlyChild.text === "") {
          return null;
        }
      }
      return {
        type: "paragraph",
        children: eat(content.children, field, imageCallback)
      };
    case "code_block":
      return {
        type: "code",
        lang: content.lang,
        value: content.value
      };
    case "mdxJsxFlowElement":
      const { children, attributes } = stringifyProps(content, field, false, imageCallback);
      return {
        type: "mdxJsxFlowElement",
        name: content.name,
        attributes,
        children
      };
    case "blockquote":
      return {
        type: "blockquote",
        children: [
          {
            type: "paragraph",
            children: eat(content.children, field, imageCallback)
          }
        ]
      };
    case "hr":
      return {
        type: "thematicBreak"
      };
    case "ol":
    case "ul":
      return {
        type: "list",
        ordered: content.type === "ol",
        spread: false,
        children: content.children.map((child) => listItemElement(child, field, imageCallback))
      };
    case "html": {
      return {
        type: "html",
        value: content.value
      };
    }
    case "img":
      return {
        type: "image",
        url: imageCallback(content.url),
        alt: content.alt,
        title: content.caption
      };
    default:
      throw new Error(`BlockElement: ${content.type} is not yet supported`);
  }
};
var listItemElement = (content, field, imageCallback) => {
  return {
    type: "listItem",
    spread: false,
    children: content.children.map((child) => {
      if (child.type === "lic") {
        return {
          type: "paragraph",
          children: eat(child.children, field, imageCallback)
        };
      }
      return blockContentElement(child, field, imageCallback);
    })
  };
};
var blockContentElement = (content, field, imageCallback) => {
  switch (content.type) {
    case "blockquote":
      return {
        type: "blockquote",
        children: content.children.map((child) => blockContentElement(child, field, imageCallback))
      };
    case "p":
      return {
        type: "paragraph",
        children: eat(content.children, field, imageCallback)
      };
    case "ol":
    case "ul":
      return {
        type: "list",
        ordered: content.type === "ol",
        spread: false,
        children: content.children.map((child) => listItemElement(child, field, imageCallback))
      };
    default:
      throw new Error(`BlockContentElement: ${content.type} is not yet supported`);
  }
};
var getMarks = (content) => {
  const marks = [];
  if (content.type !== "text") {
    return [];
  }
  if (content.bold) {
    marks.push("strong");
  }
  if (content.italic) {
    marks.push("emphasis");
  }
  if (content.code) {
    marks.push("inlineCode");
  }
  return marks;
};
export {
  parseMDX,
  stringifyMDX
};
