/**

*/
import { TinaCloudSchemaEnriched, TinaCloudSchemaBase, TinaCloudCollection, Templateable, Collectable, CollectionTemplateable } from '../types/index';
declare type Version = {
    fullVersion: string;
    major: string;
    minor: string;
    patch: string;
};
declare type Meta = {
    flags?: string[];
};
/**
 * TinaSchema is responsible for allowing you to look up certain
 * properties of the user-provided schema with ease.
 *
 */
export declare class TinaSchema {
    config: {
        version?: Version;
        meta?: Meta;
    } & TinaCloudSchemaBase;
    schema: TinaCloudSchemaEnriched;
    /**
     *
     * Create a schema class from a user defined schema object
     *
     * @param  {{version?:Version;meta?:Meta}&TinaCloudSchemaBase} config
     */
    constructor(config: {
        version?: Version;
        meta?: Meta;
    } & TinaCloudSchemaBase);
    getIsTitleFieldName: (collection: string) => string;
    getCollectionsByName: (collectionNames: string[]) => TinaCloudCollection<true>[];
    getAllCollectionPaths: () => string[];
    getCollection: (collectionName: string) => TinaCloudCollection<true>;
    getCollections: () => TinaCloudCollection<true>[];
    getGlobalTemplate: (templateName: string) => {
        label: string;
        name: string;
        ui?: import("../types/SchemaTypes").UICollection;
        fields: import("../types/SchemaTypes").TinaFieldInner<true>[];
        namespace: string[];
    };
    getCollectionByFullPath: (filepath: string) => TinaCloudCollection<true>;
    getCollectionAndTemplateByFullPath: (filepath: string, templateName?: string) => {
        collection: TinaCloudCollection<true>;
        template: Templateable;
    };
    getTemplateForData: ({ data, collection, }: {
        data?: unknown;
        collection: Collectable;
    }) => Templateable;
    transformPayload: (collectionName: string, payload: object) => {
        [x: string]: {
            [x: string]: {};
        };
    };
    private transformCollectablePayload;
    private transformField;
    isMarkdownCollection: (collectionName: string) => boolean;
    /**
     * Gets the template or templates from the item.
     * Both `object` fields and collections support
     * the ability for an object to be polymorphic,
     * and if it is, we need to build unions, which
     * are more of a headache for non-polymorphic
     * needs, so we also need the ability to just
     * build object types
     *
     *
     */
    getTemplatesForCollectable: (collection: Collectable) => CollectionTemplateable;
}
export {};
